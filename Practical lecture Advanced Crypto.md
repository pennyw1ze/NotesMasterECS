
ZK-SNARKS
- Non interactive zero knowledge;

We do not have random oracle, but thrusted parameters.
crs = thrusted parameters;

SIMULATOR:
has extra power given by:
- Simulator can re run the verifier multiple times;
- Control the random oracle;
- A simulator can generate an indistinguishible crf;

KNOWLEDGE ASSUMPTION
If an adversary can compute a secret in a protocol, the there exists an extractor that can break the algorithm and we prove PoK.
###### Succintness
- Remember that the proof is independent of NP witness size;
- Verifier makes a few computations;

There is a tradeoff between the security of proof and the succintness.

---
# Code

CIRCOM

Dot product:
2 signal, a and b;
a and b are group elements;
Proof I want to produce:
I know 2 vectors such that the output is out;

BASiC IDEA:
We have 2 vector A and B and we do the sum of the multiplication of the various position.
$\sum_{i = 0 -> (n-1)} A[i]\times B[i]$

VISUALIZATION:
			 X*X	
             /    \
        /               \
	/                          \
A = [   X    X     X ] B = [ X   X   X ]
Where X are elements of the circuit.

The result of each product, addiition ecc. is a costraint.

Commands to run the code:
```bash
mkdir -p output/
circom circuits/dot-product.circom --rlcs --wat --wasm --output output/dot-product
```

Circum translated in wasm.

Show info on the result
```bash
snarkjs rlcs info output/dot-product.rlcs
```

To show the circuit:
```circom
circom circutis/dot-product.circom --sym --output ./output/
```

Gen witness:
```bash
node /output/dot-product_js/generate_witness.js output/dot-product.wasm input/dot-product.json output/dot-product.wtns
```

groth:
we have thrusted parameters and app-specific thrusted parameters.
CRF: Polynomial of a certain degree.
crs (like crf) are circuit-specific and must be generated by several players.
Circuit dependent crs is computed starting from poweroftau (Safely generated parameters).
When we build circuits, we can use only addition and multiplication, we cannot use if statements.