## BFS
it can be used for classical planning, and it can be defined as sequential steps. We also use **best-first search** that uses an evaluation function to choose, at every iteration, the best choce given the stuation. 
This is called *blind search*, because we are not using information about the domain in our search.
# Informed Search
Apriori we can use some optimizations so that we don't consider redundant/useless paths (like loops). We are _restricting_ the search, by also considering its costs.
==**Informed/Heuristic Search** uses a heuristic function==, which easily computes the distance from the goal. In our simplified Wumpus, a heuristic function may be the distance of horizontal/vertical movements needed to go to the goal. 

Evaluation function uses $f(n) = g(n) + h(n)$, where
- $g(n)$ is the actual cost of reaching $n$
- $h(n)$ is an _estimate_ of cost to reach the goal from $n$ 

|                                                                                                                                                                                                                                                                                                                                                                                                                 |                                           |
| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------- |
| While expanding the tree, we may see that we get back to a state previously discovered. Being there with a longer path, we'll see that $g(s)$ has a higher value than what has been previously calculated, so we discard it (loop!)<br>The process is called **pruning** the tree, making it more efficient.<br><br>We add the cost to best-first search to consider this and to check what nodes to disregard. | ![[Pasted image 20250403140502.png\|400]] |
> A heuristic function h is __admissible__ if it does not overestimate the cost of reaching a solution for all states. If A* uses an admissible heuristic function, then it is OPTIMAL.

We modify the Best-first search by extracting the $<p,s>$ which has the minimal $\{g(p) + h(s)\}$ with $g(p)$ the cost of the plan given the number of nodes in the plan itself. We add a node to the Frontier iff it hasn't been seen before or if the cost is lower than what it has been reached before (by checking Marked that now contains the node and the cost).
## Heuristic function
First step is finding when an admissible Heuristic function is "good". Since the function returns an estimate which is never overestimated, if we have two functions $h_1, h_2$ we should choose the one which returns an estimation closer to the actual distance - for example $h_1(s) < h_2(s) < d(s,g)$ (and so the one which has a bigger value), since it provides a better estimation. In this case we say that $h_2$ **dominates** $h_1$.
# Planning Domain Definition Language
**Also shortened to PDDL**. Compact way to write deterministic planning. Among the first planning language, coming from *STRIPS: Standard Research Institute Planning System*. We'll first see STRIPS-based PDDL, then ADL (Action Description Language)-based PDDL. They are not cross-compatible.
### Presented with examples:
Blocks Worlds example: We are given a set of boxes $(A,B,C)$.They can be layed down on a table flat or they can be stacked. A robotic arm may pick boxes and move them around in the XY axys, doing actions: `Move`, `MoveToTable`. We wil model this domain using PDDL:

$$D = <S, A, \delta>$$
This file defines the domain:
```PDDL
(define (domain BlocksWorld)
	(:requirements :strips :negative-preconditions) ; This is a comment
	
	(:predicates
		(on ?b1 ?b2 - object)
		(onTable ?b - object)
		(clear ?b) ; not necessary to write type if is `object`
	) ; This allows us to represent the States
	
	(:action moveFromTable
		:parameters (?b1 ?b2)
		:precondition (and (clear ?b1) (clear ?b2) (ontable ?b1))
		:effect (and (on ?b1 ?b2) (not (onTable ?b1)) (not (clear ?b2))) ; We
				; have negative-precondition 
				; to add the negative precondition
	)
	(:action moveToTable
		:parameters (?b1 ?b2)
		:precondition (and clear(?b1) (on ?b1 ?b2))
		:effect ( and(not (on ?b1 ?b2)) (onTable ?b1) (clear ?b2))
	)
	(:action moveFromBlock
	:parameters (?b1 ?b2 ?b3)
	:precondition (and (clear ?b1) (clear ?b3) (on ?b1 ?b2))
	:effect (and (not (on ?b1 ?b2)) (clear ?b2) (on ?b1 ?b3) (not( clear ?b3)))
	)
)
```
## Qualification Problem
Problem of specifying the conditions in which an action can be executed. We resolve this by having the `:precondition`
## Frame Problem
Problem of specifying what does it change in the system. It's resolved by saaying that if something hasn't been mentioned, it didn't change.
## Ramification Problem
Problem is concerned with the indirect consequences of an action. It might also be posed as how to represent what happens implicitly due to an action or how to control the secondary and tertiary effects of an action. It is strongly connected to, and is opposite the qualification side of, the frame problem. Limit theory helps in operational usage.