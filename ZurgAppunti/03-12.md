# DPLL Algorithm
Unit Propagation is a sub-procedure which takes the formula as an input and the interpretation of the current sub-formula.
- Given the formula it checks for a unit clause, and if there is it'll extend the Interpretation to satisfy that. From the formula we'll then remove all occurrences of the negated literal of the unit clause, and we'll remove all clauses that contain the literal.
In the case in which we are left with a set of empty clause then our  interpretation satisfies our partial solution; otherwise we need to apply the splitting rule to the clause, by selecting one literal and adding a unit clause of that literal, and running DPLL on that.

DPLL has a time complexity $O(2^m)$, but in most cases it's much faster to build the truth table. 
### Example 1
$$\phi = \{\{p,q,r,s\}, \{\neg p, q, \neg r\}, \{\neg q, \neg r, s\},\{p, \neg q,r,s\},\{q, \neg r, \neg s\},\{\neg p, \neg r, s\},\{\neg p, \neg s\},\{p, \neg q\}\}$$
UnitPropagation doesn't have a single literal to propagate, so we'll continue.
 - We'll randomly pick the literal $\neg q$ and extend it. Unit-Propagation will return $I = \{\neg q\}$:
	 - $\phi = \{\{p,r,s\}, \{\neg p, \neg r\}, \{\neg r, \neg s\},\{\neg p, \neg r, s\},\{\neg p, \neg s\}\}$
	- Extending it with $\neg r$:
		- $\phi = \{\{p,s\},\{\neg p, \neg s\}\}$
		- Doesn't work!
	- Trying it with $r$:
		- $\phi = \{\{\neg p\}, \{\neg s\},\{\neg p, s\},\{\neg p, \neg s\}\}$
		- Applying Unit-Propagation we'll return $I=\{\neg p, \neg q, r, \neg s\}$ $\square$
### Example 2
is $\phi$ valid?
$\phi = (a \supset b) \wedge (\neg c \vee d) \wedge (f \supset \neg e) \wedge (e \vee \neg f \vee \neg b)$
To do this we'll see if $\neg \phi$ is satisfiable $\implies \exists I : I \models \neg \phi$. If we get an open branch we know it's not satisfiable (we use the tableau)
$\neg \phi = \neg(a \supset b) \vee \neg(\neg c \vee d) \vee \neg(f \supset \neg e) \vee \neg(e \vee \neg f \vee \neg b)$
we'll apply $\beta$-rule.
- $\neg (a \supset b)$: $\alpha$-rule
	- $a, \neg b$
	- Open branch: ==$\phi$ is not valid, since $\neg \phi$ is not satisfiable!==
- $\neg(\neg c \vee d) \vee \neg(f \supset \neg e) \vee \neg(e \vee \neg f \vee \neg b)$
# First Order Logic (FOL)
It's more powerful and expressive than propositional logic, since it considers attributes and uses $IS-A$ relationships. Everything that concerns propositional logic is finite, while we need a representation that can be of infinite size.

## Objects in FOL
FOL assumes that world is constituted by:
- **Individual Objects**, denoted by *constants* that talk about an objects
	- Mary
	- John
- **Functional means to refer to Objects**, denoted by functions
	- *Italian(fatherOf(Luca))*
- **Properties and relations**, denoted by *predicates*
	- *Person(Mary)*
	- *Person(John)*
	- *Mortal(Mary)*
	- *Siblings(Mary, John)*
- **Quantifiers** that get assigned globally to variables.
	- $\forall x. Person(x) \rightarrow Mortal(x)$
	- $\exists x. Person(x) \rightarrow Mortal(x)$ 
## Symbols
We have **Logical symbols**:
- Propositional logic connectives
- Quantifiers
- Enumerable set of variable symbols
- Equality predicate symbol
We have **Non-logical symbols**:
- Enumerable set of constants, functional symbols, associated with an arity
- Enumerable set of predicate symbols
## Well formed formulas
- if $t_1$ and $t_2$ are terms, then $t_1 = t_2$ is a formula
- if $t_1, ..., t_n$ and terms and $P/n$ is a predicate symbol, then $P(t_1, ..., t_n)$ is an atomic formula
- 