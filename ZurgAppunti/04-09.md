# Non Deterministic Planning
**How to represent domain, in a compact way?**
we'll introduce a variant of PDDL such that we can express non-deterministic actions, using the `oneof` key. 
- **oneof**: allows to specify a set of possible effects.
	- `oneof(e1 ... en)`, where each $a_i$ is a deterministic effect. 
	  After executing the action, one and only one effect will be applied, which is not known before the execution.

We'll use back the BlocksWorld domain
```
(define (domain BlocksWorld)
	(:requirements :non-deterministic :equality :typing)
	(:types block)
	(:predicates
		(holding ?b - block) ; arm holding block ?b
		(emptyhand) ; arm is not holding anything
		(clear ?b - block) ; block ?b not having blocks on top
		(on-table ?b - block) ; block ?b is on table
		(on ?b1 ?b2 - block) ; block ?b1 is on top of ?b2
	)
	
	; Action list
	
	(:action pick-up
		:parameters (?b1 ?b2 - block)
		:precondition (
			(and 
				(not (= ?b1 ?b2))
				(emptyhand)
				(clear ?b1)
				(on ?b1 ?b2)
			)
		)
		:effect ( ; block may slip off of the arm and fall
			oneof(
				and( ; effect accounting of successful execution
					(clear ?b2)
					(holding ?b1)
					(not (emptyhand))
					(not (on ?b1 ?b2))
					(not (clear ?b1))
				)
				and( ; effect of failing execution (block falls on table)
					(clear ?b2)
					(not (on ?b1 ?b2))
					(on-table ?b1)
					; emptyhand and clear ?b1 DID NOT CHANGE from precon
				)
			)
		)
	)

	(:action pick-up-from-table
		:parameters (?b - block)
		:precondition( and( (on-table ?b) (emptyhand) (clear ?b)) )
		:effect(oneof
			(and ) ; unsuccessful event
			(and (not (clear ?b)) (not (emptyhand)) 
				(holding ?b) (not(on-table ?b))
			)
		)
	)

	(:action put-on-block
		:parameters (?b1 ?b2 - block)
		:precondition ( and( (holding ?b1) (clear ?b2)) (not (= ?b1 ?b2)) )
		:effect(oneof
			(and (on ?b1 ?b2) (clear ?b1) (not (clear b2)) 
				(emptyhand) (not (holding ?b1)))
			(and (on-table ?b1) (clear ?b1) (emptyhand) (not(holding ?b1)))
		)
	)

	; this is deterministic!
	(:action put-down
		:parameters (?b - block)
		:precondition ( (holding ?b) )
		:effect ( and (ontable ?b) (emptyhand) (not (holding ?b)) (clear ?b) )
	)
)
```

A state has been previously introduced as a **set of facts**. For example, 2 blocks on the table and a harm can be defined as:
- **s0**: (on-table ?b1) (on-table ?b2) (clear ?b1) (clear ?b2) (emptyhand)
and with an action `pick-up-from-table b1` we may have two possibilities
- **s0 - state not changing-**: (on-table ?b1) (on-table ?b2) (clear ?b1) (clear ?b2) (emptyhand)
- **s1**: (not (clear ?b1)) (not (on-table ?b1)) (not(emptyhand)) (holding ?b1) (clear ?b2) (on-table ?b2)
### Function Symbls
- Symbols representing functions: parent-of/1
- **Terms**: either a variable $v$ or a constant $c$
	- **function term**: if $f/n$ is an n-ary function symbol then $f(t_1, ..., t_n)$ where $t_i$ is a term, is a term
- **Interpretation**: Is a pair $<\Delta, I>$ where $I$ is a function such that:
	- For every constant $c : I(c) \in \Delta$
		$\Delta : \{s_1, .., s_n\}$ 
	- For every predicate $p/n$
		$I(p) \in \Delta^n$
		FOr eample $Friends/2$ $I(Friends) = \{<s_1, s_2>, ..., <s_{n-1}, s_n>, <s_n, s_{n-1}>\}$
	- For every function symbol $f/n$
	 $I(f) = f^I$ where $f^I:\Delta^n \rightarrow \Delta$ 
In this new place, constants are a special case of function that return an object

$I, \alpha \models P(t_1, ..., t_n)$ iff $<t_1^{I,\alpha}, ..., t_n^{I,\alpha}> \in p^I$
- If $t_i$ is a variable $v$, $t_i^{I,\alpha} = \alpha (v)$ 
- If $t_i$ is a constant $c$, $t_i^{I,\alpha} = c^I$
- If $t_i$ is a functional term $f(t_1',...,t_n')$ then
# Situation Calculus
FO Language to specify (deterministic) dynamic domains. Functions are in FOL.
## Sorted language
Feature of situation calculus, which has object sorts (kind of as types).
Object domain can be partitioned into three subsets:
$\Delta = (Objects, Actions, Situations)$
- **Actions**: Represent the actions that can be executed in the domain
- **Situations**: Represent possible world histories
### Actions
We need syntax to denote features: we'll use Action Types, which corresponds to PDDL schemas. $\mathcal{A} = \{A_1/a_1, ...,  A_n/a_n\}$
Example:
- $\mathcal{A} = \{put-on-table/1, pickup-from-table/1, put-on-block/2 ,pick-up/2\}$
$pick-up(b_1, b_2)^I = act_4$
With functions we represent actions terms, and we return actions.
### Situations
World histories, having executed specific actions. 
- $s_0$: situation where no action has been performed
From this first situation we can execute actions are have different situations.

$do(a,s)$, where $a$ is an action term (e.g. `put-down(b)`) and `s` is a situation term (e.g. $s_0$ itself). This returns another situations, that is the result of applying the action $a$ over the situation $s$.

$\Sigma$ is the set of constraints, foundational axioms of Situational Calculus.
### Fluents
**fluents** are predicates where values may change from situations to situations
$Friends(p,s,s_0)$
$\neg Friends(p,s, do(steal(p, Tablet),s_0))$
Non-fluents are predicates which values never change
### Precondition check
$Poss(a,s)$ :  specifies when action $a$ is executable in situation $s$. It verifies the precondition given the situation in input, and returns $True$ or $False$.
