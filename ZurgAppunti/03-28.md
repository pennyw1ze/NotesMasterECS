# Classical Planning

We can adapt the previous code to return also, if possible, a solution path.

> [!NOTE]
> It's random since we aren't selecting smartly what node to choose.


This is not ideal - The state space becomes incredibly large as we'll record all possible plans, becoming a exponential space. We may consider different extraction policies, maybe by using BFS (which was the one i've implemented first in the algorithm, whoops).ù

We'll create a function that is decisional over the desirability of taking that action $f:S\rightarrow R$, and create a **best-first search**.

```
bool BF-Search(D, s_0, G){
	set Marked = {s_0}
	set Frontier = {s_0} // open set, contains set of states while we search
	while Frontier not empty{
		<path, state> <p,s> = extract pair s.t. max{f( <path, state> in Frontier)}
		if i in G{
			return <p,s>
		}
		for a in alpha(i){
			j = delta(i, a)
			if j not in Marked{
				Frontier.push(<p°a, j>)
				Marked.push(j)
			}
		}		
	}
	return False
} 
```
### Manhattan Distance
Sums of horizontal and vertical distance to the goal. We may use this to expand nodes that have shorter Manhattan distance (in certain situations it may not be the best one, think of maze).

To have an algorith usable as a solution, it should have some provable properties:
### Properties
- **Soundness**: Property that asks that the sequence of actions returned by the algorithm is a solution to the problem. _The algorithm in itself should be sound_. 
- **Completeness**: This property asks that the algorithm returns a solution to the problem, if it exists.
- **Optimality**: We may also want to guarantee that, if there exists a solution, the algorithm returns the best, within a given measure. In the case of BFS, we know it's optimal because of its inherent properties on Graph paths.


> [!NOTE]
> Fox was here

