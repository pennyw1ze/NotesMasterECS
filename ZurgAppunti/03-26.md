# FOL Query

> A FOL query is an open FOL formula for which we answer by assigning free variables;
> A __FOL BOOLEAN QUERY__ is a FOL query without free variables.

> Given an interpretation $I$, the _answer to a query $\varphi(x_1,...,x_k)$ is
> $$\varphi(x_1,...,x_k)^I = \{(a_1, ..., a_k) \ |\ I, <a_1, ..., a_k>\ \models \varphi(x_1, ..., x_k)\}$$

Hence, the answer of a boolean query is defined as follows.
$$
\varphi()^I = \{() | I, ()\models \varphi()\}
$$
Conventionally, if result is $\{\}$ then it's _true_, otherwise it's false.
## Query Evaluation Problem
- **Query Answering problem**: Given a finite interpretation $I$ and a FOL query $\varphi(x_1, ..., x_k)$ compute $\varphi^I$ .
- **Recognition problem**: Given a finite interpretation $I$, a FOL query $\varphi(x_1, ..., x_k)$ and a tuple $(a_1, ..., a_k)$, with $a_i \in \Delta^I \forall i$, check whethever the tuple $(a_1, ..., a_k) \in \varphi^I$
> [!NOTE]
> The recognition problem for query answering is the decision problem corresponding to the query answering problem.
## Algorithm 
We will define an algorithm that computes the function Truth(I, a, phi) in such a way that it returns True iff $I,\alpha \models \varphi$. We'll use an auxiliary function TermEval(I, a, t)that given an interpretation I and an assignment a, evaluates a term t returning an object in delta

```
TermEval(I, a, t){
	if(t = x in Vars)
		return a(x);
	f (t = f(t_1, ..., t_k))
		returns f^I(TermEval(I, a, t_1), ..., TermEval(I, a, t_k));
}
```

```
boolean Truth(I, a, phi){
	if (phy is t_1 == t_2)
		return TermEval(I, a, t_1) == TermEval(I, a, t_2);
	if (phy is P(t_1, ..., t_k))
		return P^I(TermEval(I, a, t_1), ..., TermEval(I, a, t_k));
	if (phi is not psi)
		return !TermEval(I,a, psi);

	[...]
}
```
## Wumpus in FOL
We'll have observations that we will save in $\Gamma$, so that we can rule out all interpretations incompatible with observations. We check observation and knowledge base to see if we can obtain intrinsic rules.

- Every square has exactly one in top, bottom, left and right to move
# Planning
We talked about the deductions based on our observation. ==With planning, we'll perform deterministic actions that change the world and we'll reason on them, to achieve a certain goal.==

> A **domain** is a representation of the model we are adding in. 

Given our grid domain, our actions are UP, DOWN, LEFT, RIGHT.
Some relevant properties are:
- Position of agent - changeable -> *fluent* 
- Position of goal - static -> *non-fluent*
- Structure of grid - static -> *non-fluent*

As an example, the action UP may change the position of the agent.

 > [!NOTE]
 > the language to set a planning and its rules is **Planning Domain Definition Language** (PDDL).
 
 
- **State space**: A state space can consist of finite or infinite states
- **Actions**: are finite, will be used to move between states
- **Transition function**: $\delta: S \times A \rightarrow S$. It's the transitional function that transitions from a state to another, given the original state and the action.