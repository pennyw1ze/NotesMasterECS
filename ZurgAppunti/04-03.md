# PDDL Planner
We have introduced yesterday the *domain file*. We'll now introduce the **Problem File**, that concerns with the initial state and the goal state.
```
(define (problem BlocksWorldProblem)
	(:domain BlocksWorld [^1])
	(:objects A B C)
	(:init (onTable A)
		   (onTable B)
		   (onTable C)
		   (clear A)
		   (clear B)
		   (clear C)
	) ; we are working with the closed world assumption (like DBs) where
	  ; everything that isn't mentioned is automatically false
	
	(:goal (and (on B C)
				(on A C)
		)
	)
)
```
# Semantics
We now are given two files, so that we can have as an output a **Transition System**. We'll focus on *states*. They are set of facts.
$s_0$ is the initial state defined in the problem file:
``` 
(onTable A)
(onTable B)
(onTable C)
(clear A)
(clear B)
(clear C)
```
Since blocks are finite, we have a finite combination of state, some of which are also not admissible for our domain.
- $S$ : a subset of all possible facts built from predicats in the domain and objects from the problem file
- $A$ : Set of all possibvle actions built from actions in the domain and objects from problem file. Simple, actions are defined in the Domain File and are defined like predicates. They are finite.
- $\alpha$ : Precondition function. 
- $\delta$ : Given state and action, it gives us the next state. We need to consider the `effects` part of an action. There should be a function, so there should be only one state as an output.
With all of these we have defined the domain.
### example

|                               $s_0$ ->                               |   -> Action ->    |                                              -> $s_1$                                              |
| :------------------------------------------------------------------: | :---------------: | :------------------------------------------------------------------------------------------------: |
| ontable a<br>ontable b<br>ontable c<br>clear a<br>clear b<br>clear c | moveFromTable a b | -- removed DEL LIST<br>ontable b<br>ontable c<br>clear a<br>clear b<br>-- added ADD LIST<br>on a b |
For _any states_ in $s \in S$:
- Consider all actions $a$
- Check the precondition and keep actions that satisfy them
- For all remaining actions compute the successor state $s'$
Transition systems can be expanded online, and not necessarily precomputed!
### Simple Heuristics
Given an input problem, we can remove all negative effects, so that we only consider the parts that will give you the goal, while being problem independent.
**relaxation of the problem**: 
1. Take a state
2. Compute the sequence of actions that take to the goals without negative literals and without preconditions
3. Take shortest part.

## ADL extension to PDDL
```
(define (domain BlocksWorld)
	(:requirements :adl) ; quantifiers and negated preconditions
	(:types block)
	(:predicates
		(ontable ?b - block)
		(on ?a ?b - block)
	)
	(:action move
		:parameters (?b1 ?b2 - block)
		:precondition (and    ; calculated before applying action
			(forall (?b - block) (not (on b ?b1)))
			(forall (?b - block) (not (on b ?b2)))
		)
		:effect (and          ; calculated after applying action
			(on ?b1 ?b2)
			(forall(?b - block) (when(on ?b1 ?b) (not(on ?b1 ?b)))
								; conditional effect!
			when(ontable ?b1) (not(ontable ?b1))
		)
	)
)
```

[^1]: Get to blocksWorld domain yesterday [[Artificial Intelligence & Machine Learning/Daily/04-02|04-02]]
 