# **Intro**

A **blockchain is** a distributed ledger that can record transactions in an immutable, verifiable and permanent way.

What transactions are recorded and in which order (CONSENSUS)?
❏ permissioned
❏ permissionless

Who can read the transaction written in chain or make new proposals?
❏ private
❏ public

The main difference with a bank consists basically in the decentralization of the process:
Centralized process needs
TRUST

Decentralized process needs
CONSENSUS from the Society


##### Block processing
How does a block get into the blockchain ?
1. Transaction request is performed by a node;
2. Transaction is broadcasted trough the network;
3. Validators check the transaction;
4. Verified transaction is added to a block;
5. Block is added to the blockchain;

It is not guaranteed that different nodes has the same view.

##### Proper use of blockchain
When to use the blockchain ?
![[Pasted image 20250618165021.png]]

In [this](https://www.law.berkeley.edu/wp-content/uploads/2018/08/Do-you-need-a-Blockchain-Karl-Wust-and-Arthur-Gervais.pdf) paper you will find more details about the proper use of blockchain as a solid alternative to the centralized systems.


##### Oracles
Oracles are components that allow a blockchain, or a smart contract, to get inputs from  utside the blockchain. They inject data coming from outside the blockchain into regular  lockchain transactions. In this way, they become part of the blockchain history and can be handled deterministically by all blockchain nodes.

---
# **Tech Ingredients**

The main technologies implemented in the blockchain are:
- **Asymmetric encryption;**
- **Hash functions;**
- **Merkle trees;**
- **Key-value database;**
- **P2P comunication protocol;**
- **Proof of work/stake/whatever;**
We will analyze this technologies in detail.

#### Hash functions
We need fast to compute hash functions.
We also need collision resistant hash functions.
For this purpose we will use **cryptographic hashing functions** which are:
- **Collision resistant**: hard to find collisions;
- **Difficult to invert**: given the image of the function is hard to guess the pre-image;

In blockchain, hashing functions are used for:
- Chaining blocks;
- Commitment;
- Hash Puzzles (PoW);
- Merkle trees;
- Signature;
- Authenticity and integrity;

#### Key-value database
The only way I have to verify the integrity of the blockchain is to download the whole blockchain and check.
However, once the check is done and I’m confident it is all ok, I can use ad-hoc data structures and tool to facilitate the computation.
Also we have apis that can access easilty blockchain informations and are called trough RPCs.


#### Asymmetric encryption
How is asymmetric encryption used ?
In the bitcoin blockchain:
	- Addresses are Public Keys;
	- Addresses in bitcoin transactions are public;
	- The blockchain can be analyzed to link transactions to real people: i.e. identities;
	- A bitcoin address per se doesn't say anything about you, but your transaction history does;
	- Create new personal addresses is free;
Wallet address are public keys, private keys are using to show ownership and perform payments.
Verifiers blocks, as well as nodes that performs a transaction, sign the block/transaction, and for the digital signature the asymmetric encryption paradigm is adopted.
inputs

#### Transactions
To spend or unlock a Bitcoin **UTXO**(Unspent Transaction Output), you typically follow these steps:
1. Create a transaction: Include the UTXO as an input;
2. Specify the recipient's address and the amount to send;
3. Sign the transaction with the private key corresponding to the input UTXO;
4. Broadcast the transaction to the Bitcoin network;
A transactions is made up of fields, each contains bytes of data.
It contains some fields, such as version, marker, flag, but the most important are:
- **Inputs**: contains the TXID, the id of the transaction containing the output you want to spend, scriptsig field which contains the unlocking code for the output referenced;
- **Outputs**: This outputs are new batch of bitcoins generated by the transaction. Each batch contains the amount of money in it, and the public key that locks the output block (the wallet adress of the receiver basically);
TXID is the id of the transactions refered in other transaction and is created as follows:

```
TXID = HASH256([version][inputs][outputs][locktime])
```

What remains after the input value was spent and the output value was given, is the fee value which is splitted to the miner of the block and the validators.

##### UTXOs
UTXOs are unspent transactions output that can still be consumed as input.
Keeping track of UTXOs is useful for two reasons:

1. [Validating transactions](https://learnmeabitcoin.com/technical/transaction/utxo/#validating-transactions)
2. [Calculating address balances](https://learnmeabitcoin.com/technical/transaction/utxo/#calculating-address-balances)

The UTXO are stored in the chainstate database.This is a separate database that get  stored in memory (RAM).
When a UTXO is spent, it is marked as **spent** by being referenced as an **input** in a new transaction. Here's how it's handled:

1. **Every node** keeps a database of all current UTXOs (Unspent Transaction Outputs);
    
2. When a new transaction is validated, the node checks if the inputs refer to UTXOs in that list;
    
3. If valid, the inputs (referenced UTXOs) are **removed** from the UTXO set;
    
4. The outputs of the new transaction are **added** to the UTXO set;

A new address is generated each time you receive bitcoin. Basically the wallet is able to generate different addresses in order to "store" different UTXOs.
This addresses are tracked by the blockchain, but the blockchain has no way to know which wall has generated those addresses.
So the UTXO model is really different from that state model in which the user owns an account.

#### Transaction validation
Bitcoin transaction validation rule:
- **Syntax** check;
- Respect allowed range **value**;
- For each input, if the referenced **output exists** in any other transaction in the pool, the transaction must be rejected;
- For each input, if the referenced output transaction is a coinbase output, it must have at least COINBASE_MATURITY (100) confirmations;
- Reject if the sum of input values is less than sum of output values;
- For each input, the referenced output must exist and cannot already be spent;
- The unlocking scripts for each input must validate against the corresponding output locking scripts;

Coinbase transaction is the first transaction in a block, has TXID 0s and VOUT max and represent the generation of new coins given to the miners as a reward.
The block reward can be sent to multiple locations.
It's placed there by the miner when they construct their candidate block so they can **claim the block reward** (block subsidy + fees) if they are successful in mining the block.
The outputs from coinbase transactions are the **source of new bitcoins**.

#### Merkle tree
Already seen in advanced cryptography course.
This structure allows the miners to aggregate all the transactions in a single SHA256 string, by computing SHA256 of all the transactions and then aggregating the hashing until reaching the "root" of this tree.
In this way, to verify if a transaction is actually in a block, we will need only to hash the transaction and to provide the hashing of all the siblings in the path from the transaction (leaf) to the merke root, which is embedded in the block. So instead of providing all the transactions and computing $N$ hashes, we will just provide and compute $log(N)$ hashes and we decrease the cost of checking the transaction.
**PROs**:
- Efficiently verify the presence of a transaction in a block;
    
- Efficiently verify the integrity of a block (e.g. a transaction integrity);
    
- Limit the memory to use Bitcoin to support light clients (e.g. mobile devices);

#### Nodes
There are 3 types of nodes in the bitcoin blockchain:
- **Full nodes**: full nodes verifies and relays the transactions and the blocks. They has to independently validate the complete copy of the blockchain since they have to download the entire blockchain;
- **Light nodes**: they connects to full nodes to interact with the blockchain. It needs only the chain of the blocks headers to operate. Light nodes don't have to trust full nodes since they provide merkle proofs of the provided data. They cannot validate the entire blockchains, but can check the existance of a node, so they do not earn anything;
- **Client nodes**: relies on 3rd party host providing APIs to look into the blockchain.These clients connect to a remote node and **completely trust** its responses in a non-cryptographically-proven manner.

---
# **Consensus**

> **Goal**
> The goal of the consensus in the blockchain is to have the same blockchain on every node despite the retardered propagation of informations in different part of the globe.

**Time** and **order of events** are fundamental obstacles in a system of distributed computers that are spatially separated.

Some general results about consensus are:
**FLP**
Even a single faulty process makes it impossible to reach consensus among deterministic asynchronous processes.
To circumvent FLP, If no progress is being made on deciding the next value, wait a timeout, then start the steps all over again. (Paxos protocol approach).
This approach are not byzantine fault tough.
Permissionless and public blockchains must achieve consensus in the following settings:
- Asynchronous systems;
- Byzantine and crashing nodes;
Paxos can satisfy the first requirement but not the second one. 
How do we deal with byzantinte ?
If there are $f$ byzantine process, the consensus can be achieved only if there are $3f + 1$ total nodes (look at [[Dependable Distributed System Recap#Byzantine tolerant Consensus]]).
We adopt new comunication primitives:
- Every message that is sent is delivered correctly;
- The receiver of a message knows who sent it;
- The absence of a message can be detected;
- A loyal general's signature cannot be forged, and any alteration of the contents of his signed messages can be detected;
- Anyone can verify the authenticity of a general's signature;


How do we achieve consensus ?

Let's start talking about how consensus is actually achieved in the bitcoin blockchain.
1. All the mining nodes pull transactions when they are published and creates blocks;
	
2. The block must then be attached to the blockchain (Proof of work);
	
3. If 2 ore more miners achieve the result simultaniously, then more blocks are attached at the same time to the same block and the a fork is created in the blockchain;
	
4. At this point, new transactions will be generated and new miners will create new blocks. This new blocks will be attached to one of the 2 "new chain" that forked from the original one;
	
5. When one of the 2 "new chain" becames longer then the other one (this is proved that will happen), the shortes chain is discarded and all the transactions in that chain will be re-mined into new blocks;

Since the lenght of the forked chain is not the same to everybody and forks could grow in different way in different machines around the world, a timer is added to slow down the growth of the blockchain.
This timer is the proof of work.

## Proof of Work
The proof of work consists in a complicated math puzzle that is slow to be solved for every machine and requires enough computational power to solve the challenge.
Nowadays a bitcoin puzzle requires 10 minutes circa.
Who solves the puzzle becomes the leader and can attach the next block to the blockchain.
##### The challenge
The challenge consists in reversing an hashing function.
Since hashing functions are hard to invert, the online chance for the miner is to bruteforce the hashing function. This require a lot of computational power which is not easy to accumulate. The challenge usually consists in finding the pre-image of the hashing function such that the image has a certain amount of zeros at the beginning. This challenge is post-quantum secure.

We still may have 2 simultanious winners to the challenge, and thus a fork is created.
Clearly the chain will not grow so fast since at least 7/8 minutes are required for the challenge to be solved, so it will be easy to detect the longest chain for every node in the chain.

There are a lot of controversial about the sustainability of the proof of work model expecially about the environmental point of view. A lot of work goes lost, wasting time and energy.

If a hacker is able to secure control of more than half of the network (51%), they are able to alter a blockchain and manipulate transactions to steal from the network. In blockchain, the more nodes, the more security.


#### PoW to PoS
In PoW we had:$$H(previous\_hash,merkle\_root,nonce)<K;$$
The miner tries nonces up to the time in which he find the right one which makes the hashing output less then K (with a fixed amount of 0s at the begging of the hash).
In PoS we have:$$VRF(sk_i, ts, previous\_hash) < K\times stake;$$
- $ts$: otherwise there could be stall (no parameters matching the desired output);
- $stake$: we need the difficulty of the challenge to be proportioned to the stake;
- $sk_i$: the outcome is bounded to the single identity;
- $VRF$: function that given an input generates a pseudo-random number and a proof that the generated number as been obtained with $ts,\ previous\_hash$ and a $sk$ associated to $pk$;

##### Nothing at stake attack
The adversary tries to grow blocks everywhere in the blockchain, since the only element on which he can try to cheat is the previous_hash inside the VRF. The NaS attack has been proved to be successful when $eβλ > (1 − β)λ$, $i.e., β \ge {1\over(1 + e)} = 26.89\%$, where $\beta\lambda$ s the adversarial mining rate.
**Solutions**
Ouroboros PoS Protocol:$$VRF(hash(Genesis), ts, sk_n) < T · stake_n$$
Fails in the bribe attack (winner can be precomputed and bribed).
Correlation PoS Protocol:$$VRF(RandSource(parent), ts, sk_n) < T · stake_n$$
where$$RandSource(b) = \begin{cases}
   VRF(RandSource(parent(b)), ts, sk) &\text{if } depth(b)\%c = 0, \\
   RandSource(parent(b)) &\text{otherwise. }
\end{cases}
$$
## Proof of Stake

**General idea**
The idea is that if we can fairly reduce the number of participants to the consensus we can speed up the process. We will do a weighted lottery where participants will place stake that they hold to participate to the lottery and the probability to win the lottery will be proportioned to the stake placed. If the validator choosen in the lottery is malicious and tries to validate a malicious block, his stake will be sliced an he will loose money. There is a minimum and a maximum amount of eth with which the participants can join the lottery with their stake.

**Details**
How does the block production works in the PoS architecture?
An epoch is created, which last around 6.4 minutes. In an epoch there are 32 time slots, circa 12 second per slot. In each slot there will be a block proposal (can also be NULL if the proposer is offline).

How does the process works?
Let's analise what happens in a single time slot:

**Settings**
There is a **Staking Smart Contract** which contains a list of validators, with thier withdrawal address (t allows users to receive their cryptocurrency, such as staking rewards), their public address as validator and their stake (to simplify the voting process, the stake will be 32 ETH for all validators). Your validators digital signature becomes your proof of stake because anyone can chek your stake in the contract with your public address.

**Process**
1. All validator staking in the smart contract are randomly split into equal committees by the random algorithm taken into account (Randao/Alogrand). Each committee is assigned to one time slot in the epoch;
	
2. The first member of the committee is choosen to propose a block for his time slot (some slots may be empty due to validator offline). The other members of the committee must produce attestation for the proposed block (attestation is produced if the block is correctly generated). If the block is not proposed in the timeslot by the first validator, the other validators must vote for the previous block;
	
3.  Committees are divided in 128 subnets, and from this subnets with 100 participants per subnet circa, a signature is taken, so at the end we will have 128 signatures that represents 12'000 signatures;
	
4. If more then 2/3 of the committee validates the proposed block, it is attached to the beacon chain;
	
5. Validators also police each other and are rewarded for reporting other validators that make conflicting votes, or propose multiple blocks. If a validator is caught cheating, his stakes are slashed (basically he loose some of his ethereum);
	
6. Validators get a reward for their actions: the block proposal as an higher reward, the attestation has a lower reward;
#### BLS signature
Ethereum uses BLS signature aggregation property to make the whole process efficient.
BLS signature are a kind of signature which are easily aggregatable, thanks to the property of EC field on which the signature is produced. This property allows to aggregate all the signature produced into a unique signature.

#### RANDAO
RANDAO is a decentralized algorithm designed to generate random numbers in a decentralized way. The idea is to combine different inputs from a large group of people instead of simply trusting a person. If there is at least one honest party between the n proposer, the number will be random.
In the case of ethereum, this random number is the digital signature of the file which is produced with the private key of each verifier. The output is unpredictable unless the private key is known. The signatures are aggregated togheter with BLS to produce the final random number.

#### Fork
In presence of forks, there are different methods to solve the problem.
###### **Ghost**
With Casper we apply the usual method of the **longest chain**, considering that not only the lenght of the chain is considered, but also the **heigt**, so the total number of the blocks produced after the fork is what really matters. 
If the number of blocks is the same, the **number of attestation** produced by the validators is taken into account: the chain with the grater number of attestation is taken into account, the other are discarded.

###### **Casper**
Shows when a block becames final.
When we adopt a Byzantine Fault Tolerant algorithm to reach consensus, we run 2 rounds of voting, and when the block reaches the 2/3rd of the committee votes it becames final.
In the first round the validators committs the votes, and in the second round they go trough the votes.
We need 2 rounds because at the first round we could have an attacker double voting and placing the block in a situation where there is an equal number of votes and it exceeds the 50% each (since he voted twice). After the first round he will be slashed heavily and go under the 16ETH, which is the minimum amount to vote, so he will not be able to cause trouble again.


#### **Algorand**
Alternative approach to PoS.
- Among the multitude of participants, few are publicly and randomly selected to form a committee and make block proposals → VRF (weighted lottery);
- Among the committee a leader is elected and its proposal is considered. Node certify the proposal if it receives more than ⅔ of votes. Each node can either certify or not the proposal. Commeettee can receive more then one proposal if multiple nodes win the challenge: the committee will certify the propopsal of the winner with the lower VRF hash;
- A new committee can efficiently run a binary Byzantine Agreement, reach consensus and sign the result;
- After the process, either a block is approved if it received enough votes, and it is attached to the blockchain, or an empty block is finalized and attached to the blockchain;


---
# **Beyond Transactions**

## Ethereum
Ethereum can be seen as a chain of states. Each state represent the world state, and transactions represent link between a previous and a successive state.
The world state is a mapping between address and account state.

### Accounts
An account is an object in the world state, that maps an address to an account state.
There are 2 types of account:
- EOA: externally owned account, controlled by a user that owns the private key of respective address, contains nonces and the actual balance;
- Contract Account: controlled by the EVM, it contains nonces, balance, evm code and hashes stored insidel;




---
# **Blockchain and IOT**


---
# **Scaling the blockchain**


---