# Non Deterministic Planning
**How to represent domain, in a compact way?**
we'll introduce a variant of PDDL such that we can express non-deterministic actions, using the `oneof` key. 
- **oneof**: allows to specify a set of possible effects.
- `oneof(e1 ... en)`, where each $a_i$ is a deterministic effect. 
  After executing the action, one and only one effect will be applied, which is not known before the execution.

We'll use back the BlocksWorld domain
```
(define (domain BlocksWorld)
	(:requirements :non-deterministic :equality :typing)
	(:types block)
	(:predicates
		(holding ?b - block) ; arm holding block ?b
		(emptyhand) ; arm is not holding anything
		(clear ?b - block) ; block ?b not having blocks on top
		(on-table ?b - block) ; block ?b is on table
		(on ?b1 ?b2 - block) ; block ?b1 is on top of ?b2
	)
	
	; Action list
	
	(:action pick-up
		:parameters (?b1 ?b2 - block)
		:precondition (
			(and 
				(not (= ?b1 ?b2))
				(emptyhand)
				(clear ?b1)
				(on ?b1 ?b2)
			)
		)
		:effect ( ; block may slip off of the arm and fall
			oneof(
				and( ; effect accounting of successful execution
					(clear ?b2)
					(holding ?b1)
					(not (emptyhand))
					(not (on ?b1 ?b2))
					(not (clear ?b1))
				)
				and( ; effect of failing execution (block falls on table)
					(clear ?b2)
					(not (on ?b1 ?b2))
					(on-table ?b1)
					; emptyhand and clear ?b1 DID NOT CHANGE from precon
				)
			)
		)
	)
	
	(:action pick-up-from-table
		:parameters (?b - block)
		:precondition(
			and( (on-table ?b) (emptyhand) (clear ?b))
		)
		:effect(oneof
			(and ) ; unsuccessful event
			(and (not (clear ?b)) (not (emptyhand)) 
				(holding ?b) (not(ontable ?b))
			)
		)
	)
	
	(:action put-on-block
		:parameters (?b1 ?b2 - block)
		:precondition ( and( (holding ?b1) (clear ?b2)) )
		:effect(oneof
			(and (on ?b1 ?b2) (clear ?b1) (not (clear b2)) 
				(emptyhand) (not (holding ?b1)))
			(and (on-table ?b1) (clear ?b1) (emptyhand) (not(holding ?b1)))
		)
	)

	(:action put-down
		:parameters (?b - block)
		:precondition ( (holding ?b) )
		:effect ( and (ontable ?b) (emptyhand) (not (holding ?b)) (clear ?b) )
	)
)
```


A:
- Parameters
- Precondition
- effect
Same as in classical planning;

---
# Situation calculus

FO lenguage to specify(deterministic) dynamic domains.
Functions in FOL.

Functions symbols:
- Symbols representing functions: parent-of/1;

Terms: either a variable v of a constant c of a function term.
function term: if f/n is an n-ary function symbol then f(t1,t2,...,tn) where ti is a term, is a term.
Interpretation I is a pair $<\Delta,I>$function s.t. for every constant c,: I(c) $\in$ I.
For every predicate P/n:
I (P) $\subseteq \Delta ^n$ 


For every function symbol f/n:
$I(f) = f^I$ where $f^I:\Delta^n \rightarrow \Delta$ 
Notice that is a TOTAL function.

## Sorted language
Feature of situation calculus, which has object sorts (kind of as types).
Object domain can be partitioned into three subsets:
$\Delta = (Objects, Actions, Situations)$
- Actions: Represent the actions that can be executed in the domain
- Situations: Represent possible world histories
### Actions
We need syntax to denote features: we'll use Action Types, which corresponds to PDDL schemas. $A = \{A_1/a_1, ...,  A_n/a_n\}$
Example:
- $A = \{put-on-table/1, pickup-from-table/1, put-on-block/2 ,pick-up/2\}$
$pick-up(b_1, b_2)^I = act_4$#

### Situations
World history
do: function to do actions.

- $S_0$ Initial situation, where no action has been performed.
- do(a,s) where a is an action term and s is a state.


EX:

S0: all blocks on the table.

Action: pick-up(b1),$S_0$;


$\Sigma$ Set of constraints, foundational axioms of Situational Calculus Analis Tesseractes del Duxis.
Gogogò go gogogò go ...
We have a tree of state.

Fluents are predicates whos values can change from situations to situations.