### Timestamp
Concurrency based on timestamp. We define a total order based on the order in which the schedule are received from the scheduler.
The scheduler timestamps the transactions in increasing order and execute transactions following timestamps order.

For each element X we keep the following data:
- **rts(X)** next X reader;
- **wts(X)** next X writer;
- **wts-c(X)** last X writer;
- **cb(X)** a bit that is false if the transaction who wrote X lastly has not committed yet.

The system manages 2 temporal axes, **physical** and **logical** time.
The phisical time is when an action of a transaction occurs in a schedule, the logical time is the "transaction order" in which they appear in the schedule itself.
To see if transactions are compatible with each other we must have non conflicting order between phisical and logical time i.e. no transaction that has greater phisical time must have lower logical time or viceversa.
When we find a conflict, the conflicting transaction is aborted and executed again later with a new timestamp.

Also with timestamp based method we do not avoid the possibility of deadlock.
- Timestamp-based method is superior when transactions are “read-only”, or when concurrent transactions rarely write the same elements;
- 2PL is superior when the number of conflicts is high because the probability of rollback is higher in the timestamp-based method;

