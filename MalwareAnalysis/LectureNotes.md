# Assembly x86
Remeber principle concepts:
- **Words**, 16-bit long, **dword** is 32-bit long;
- **Endianess**, big is from most important to less, little is the opposite;
- **Registers**: Different categories:
	- **General purpose**: store data, ecc;
	- **Status**: hold status of the processor;
	- **Program counter**: hold address of istruction being executed;
	x86 general purpose are 32-bit long.
	We will use 8 general purpose:
	EAX, EBX, ECX, EDX, ESI, EDI, ESP, EBP.
- **Instruction cycle**: Fetch (CPU reads instructions from EIP), **decode** (control unit determines meaning of instructions), **execute** (carry out compilation);
- Remember the **stack** grows **DOWN!**
- Basic instructions:
	- mov dest,src
	- push
	- pop
	- add dest,src
	- sub dest,src
	- inc
	- dec
	- not
	- neg
	- xor dest,src
	- and dest,src
	- or dest,src
	- shr dest,src
	- shl dest,src
	- sar dest,src
	- sal dest,src
	- jmp
	- cmp dest,src
	- jcc (je,jz,jg,jl,jnl,jge,ecc...)
	- test 
	- call
	- ret
	- lea
- **Functions**: functions are just a convention, it is still all peace of code. A function is invoked with a call and execute the code untill returning a value with the ret instruction (in the return_address which is assigned at calling time);
	- Parameters are passed via stack;
	- Registers must be preserved in order to not be modified by the function. We have caller-save (pushed before a call) registers and calle-save registers (pushed in stack when the callee needs to use them);
	- On return, ESP must be re-aligned;
- **LEA**: Load Effective Address istruction, define memory address and writes it to a destination register;

---
> Lecture 2
# Basic Static Analysis

### Goals

- **Monitoring** and attack **prevention**:
	- Identify patterns;
	- Rules for monitoring;
	- Design **resilient** systems;
- Incident **response**:
	- Identify compromised asstes;
	- Contain attacks expansions;
	- **Eradicate** the attack and **recover** efficiently;

### Signatures
Make use data extracted from a host in order to identify the presence of the malware.
Ex: Hash(malware)
This works like a signature of the malware.
- **Host based**: identify process/files/ecc. on the victims pc;
- **Network** signature: analyze network traffic;
- **Behavioural** signatures: Focus on what the malware does on the system;

### Expected behaviours
- Persistence;
- Uniqueness;
- Environment check/targeting;
- Obfuscation and evasion;
- Fingerprint and beaconing;
- Communication;
We don't need to get every detail of the malware, most of the times just general behaviour is fine. Remember always to try **several tools**.

##### Hash
Hashes are used to label malwares, as well as every software, and identify this software in a unique way. The hash is like a fingerprint of the malware.
Hashes can be shared and are checked by antivirus in order to monitor running programs.

### Portable Execution
Portable execution is a file format of executable files used in windows.
It contains informations to load a file in windows. Almost every executed file in windows is in PE format.
This is the PE file basic structure:

![[Pasted image 20251010144740.png]]
The DOS header occupies the first 64 bytes of the file.
It's there in case the program is run from DOS, so DOS can recognise it as a valid executable and run the DOS stub.
Then we have a lot of flags that indicates weather:
- File is executable or DLL;
- How many section contains;
- RVA of the first istructions;
- ecc...

**Section table**
- Section name without terminating char;
- Size of the section once loaded in memory (how much space the loader will allocate for it);
- RVA of the section;
- The size of the section's data in the file on disk;
- ecc...

After the section headers we find the sections themselves.

---
> Lecture 3
# Basic Dynamic Analysis
### Main elements
- Consists in running the malware and monitoring it;
- Requires a controlled environment;
- Usefull when static analysis reach a dead-end;
- Approaches: 
	- **Diffing**: Consists in snapshotting system before and post malware execution and comparing the 2 states (tools: regshot, autoruns);
	- **Monitoring**: From a clean system state, record every individual change in system and network traffic that appears after executing the suspicious file (tools: procmon, Wireshark);
	- **Tracing**: Hook and record important API calls made by the suspicious process (tools: Rohitab API Monitor, WinApiOverride);
	- **Debugging**: Set breakpoints inside the suspicious file to stop its execution at a given location and inspect its state (tools: IDA, OllyDbg, Immunity Debugger, WinDbg);

The analysis is performed in the same space as the malware is executed. Notice that a malware can detect analysis artifacts. We may run test in fake environment called "Sandbox".
Processes interacts with the OS with System calls, so we are going to track them down in order to understand what the malware is doing.
A possible malware dynamic analysis report is expected to contain:
Report from the analysis:
- File activity;
- Registry activity;
- Start/Stop of Windows services (via Service Manager);
- Process activity;
- Network activity;

**Sandboxes** 
Sandboxes are softwares that allows the user to contain inside themself all the basic tools for a dynamic analysis. They are basically virtualized environments that simulates network services. They are expensive but easy to use, can automate analysis and produce a PDF report.

**Classification**
In sandboxes a classification is performed and a name is assigned to each analyzed malware using the following naming pattern:

![[Pasted image 20251016200153.png]]

> [!WARNING]
> Some malwares detect virtual environment, and will run only on actual machines.

There are obviously some concrete risks in running also in a virtual environment, it could have breaches that leads to the host machine and damage it.

Procmon to monitor the environment:
![[Pasted image 20251016202832.png]]



