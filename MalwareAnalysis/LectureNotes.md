# Assembly x86
Remeber principle concepts:
- **Words**, 16-bit long, **dword** is 32-bit long;
- **Endianess**, big is from most important to less, little is the opposite;
- **Registers**: Different categories:
	- **General purpose**: store data, ecc;
	- **Status**: hold status of the processor;
	- **Program counter**: hold address of istruction being executed;
	x86 general purpose are 32-bit long.
	We will use 8 general purpose:
	EAX, EBX, ECX, EDX, ESI, EDI, ESP, EBP.
- **Instruction cycle**: Fetch (CPU reads instructions from EIP), **decode** (control unit determines meaning of instructions), **execute** (carry out compilation);
- Remember the **stack** grows **DOWN!**
- Basic instructions:
	- mov dest,src
	- push
	- pop
	- add dest,src
	- sub dest,src
	- inc
	- dec
	- not
	- neg
	- xor dest,src
	- and dest,src
	- or dest,src
	- shr dest,src
	- shl dest,src
	- sar dest,src
	- sal dest,src
	- jmp
	- cmp dest,src
	- jcc (je,jz,jg,jl,jnl,jge,ecc...)
	- test 
	- call
	- ret
	- lea
- **Functions**: functions are just a convention, it is still all peace of code. A function is invoked with a call and execute the code untill returning a value with the ret instruction (in the return_address which is assigned at calling time);
	- Parameters are passed via stack;
	- Registers must be preserved in order to not be modified by the function. We have caller-save (pushed before a call) registers and calle-save registers (pushed in stack when the callee needs to use them);
	- On return, ESP must be re-aligned;
- **LEA**: Load Effective Address istruction, define memory address and writes it to a destination register;

---
> Lecture 2
# Basic Static Analysis

### Goals

- **Monitoring** and attack **prevention**:
	- Identify patterns;
	- Rules for monitoring;
	- Design **resilient** systems;
- Incident **response**:
	- Identify compromised asstes;
	- Contain attacks expansions;
	- **Eradicate** the attack and **recover** efficiently;

### Signatures
Make use data extracted from a host in order to identify the presence of the malware.
Ex: Hash(malware)
This works like a signature of the malware.
- **Host based**: identify process/files/ecc. on the victims pc;
- **Network** signature: analyze network traffic;
- **Behavioural** signatures: Focus on what the malware does on the system;

### Expected behaviours
- Persistence;
- Uniqueness;
- Environment check/targeting;
- Obfuscation and evasion;
- Fingerprint and beaconing;
- Communication;
We don't need to get every detail of the malware, most of the times just general behaviour is fine. Remember always to try **several tools**.

##### Hash
Hashes are used to label malwares, as well as every software, and identify this software in a unique way. The hash is like a fingerprint of the malware.
Hashes can be shared and are checked by antivirus in order to monitor running programs.

### Portable Execution
Portable execution is a file format of executable files used in windows.
It contains informations to load a file in windows. Almost every executed file in windows is in PE format.
This is the PE file basic structure:

![[Pasted image 20251010144740.png]]
The DOS header occupies the first 64 bytes of the file.
It's there in case the program is run from DOS, so DOS can recognise it as a valid executable and run the DOS stub.
Then we have a lot of flags that indicates weather:
- File is executable or DLL;
- How many section contains;
- RVA of the first istructions;
- ecc...

**Section table**
- Section name without terminating char;
- Size of the section once loaded in memory (how much space the loader will allocate for it);
- RVA of the section;
- The size of the section's data in the file on disk;
- ecc...

After the section headers we find the sections themselves.

---
> Lecture 3
# Basic Dynamic Analysis
### Main elements
- Consists in running the malware and monitoring it;
- Requires a controlled environment;
- Usefull when static analysis reach a dead-end;
- Approaches: 
	- **Diffing**: Consists in snapshotting system before and post malware execution and comparing the 2 states (tools: regshot, autoruns);
	- **Monitoring**: From a clean system state, record every individual change in system and network traffic that appears after executing the suspicious file (tools: procmon, Wireshark);
	- **Tracing**: Hook and record important API calls made by the suspicious process (tools: Rohitab API Monitor, WinApiOverride);
	- **Debugging**: Set breakpoints inside the suspicious file to stop its execution at a given location and inspect its state (tools: IDA, OllyDbg, Immunity Debugger, WinDbg);

The analysis is performed in the same space as the malware is executed. Notice that a malware can detect analysis artifacts. We may run test in fake environment called "Sandbox".
Processes interacts with the OS with System calls, so we are going to track them down in order to understand what the malware is doing.
A possible malware dynamic analysis report is expected to contain:
Report from the analysis:
- File activity;
- Registry activity;
- Start/Stop of Windows services (via Service Manager);
- Process activity;
- Network activity;

**Sandboxes** 
Sandboxes are softwares that allows the user to contain inside themself all the basic tools for a dynamic analysis. They are basically virtualized environments that simulates network services. They are expensive but easy to use, can automate analysis and produce a PDF report.

**Classification**
In sandboxes a classification is performed and a name is assigned to each analyzed malware using the following naming pattern:

![[Pasted image 20251016200153.png]]

> [!WARNING]
> Some malwares detect virtual environment, and will run only on actual machines.

There are obviously some concrete risks in running also in a virtual environment, it could have breaches that leads to the host machine and damage it.

Procmon to monitor the environment:
![[Pasted image 20251016202832.png]]



## Kernel vs User mode 
Nearly all code runs in user mode. User cannot access hardware directly, but is restricted to CPU call instructions and can only manipulate hardware through API.
All kernel process share resource and memory. 
Some **popular** native API calls in malware:
- NTtQuerySystemInformation;
- NTtQueryInformationProcess;
- NTtQueryInformationThread;
- NTtQueryInformationFile;
- NTtQueryInformationKey;
- NtContinue: returns from an exception, used to confuse analyst and make the program more difficult to debug;
#### Windows API 

**File:**
**CreateFile**, **ReadFile**, **WriteFile**
▪Normal file input/output.
**CreateFileMapping**, **MapViewOfFile**
▪ Frequently used by malware, loads file contents into RAM, and can be used to execute a file without using the Windows loader.

**Memory:**
**RegOpenKeyEx**
▪ Opens a registry key for editing and querying
**RegSetValueEx**
▪ Adds a new value to the registry & sets its data
**RegGetValue**
▪ Returns the data for a value entry in the Registry

**Network:**
Calls, in order, **socket**, **bind**, **listen**, **accept**
▪ Maintains an open socket waiting for connections;
Calls, in order, **socket**, **connect**,t hen **send** and **recv** as necessary
▪ Connects to a waiting socket

**Process:**
**CreateThread**
▪Caller specified a start address, also called a start function
We also have mutex to allow comunication between processes.
Mutex uses the following functions:
**WaitForSingleObject**
▪Gives a thread access to the mutex
▪Any subsequent threads attempting to gain access to it must wait
**ReleaseMutex**
▪Called when a thread is done using the mutex
**CreateMutex**
**OpenMutex**
▪Gets a handle to another process's mutex
#### DLL
Dynamic Linked Libraries, share code among different process in all the windows operating system. An attacker could:
- Store malicious code in DLL;
- Use windows or third party DLL in his advantage;
DLLs are executable files, with a main Dllmain function which is called when the library is loaded.

# Malware evasion

**Red pill**: Procedure to understand if a program is running in a virtual environment. It uses:
▪ instructions that take longer to execute (mainly cpuid)
▪ instruction errata (e.g., incomplete emulation)
▪ CPU identification data from cpuid
▪ system firmware tables (e.g., SMBIOS strings, ACPI tables)
▪ contents and position in memory of specific structures (e.g., Interrupt Descriptor Table)
▪ micro-architectural state of the machine
▪ I/O ports